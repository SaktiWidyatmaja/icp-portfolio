import { query, update, Record, Canister, Err, text, StableBTreeMap, None, Some, Vec, Result, nat64, nat16, ic, Opt, Principal } from 'azle';
import { v4 as uuidv4 } from 'uuid';

const Education = Record({
  degree: text,
  school: text,
  graduationYear: nat16,
})

const Experience = Record({
  experienceId: text,
  position: text,
  startTime: nat64,
  endTime: nat64,
  description: text,
})

const ExperiencePayload = Record({
  position: text,
  startTime: nat64,
  endTime: nat64,
  description: text,
})

const Project = Record({
  projectId: text,
  role: text,
  description: text,
  techStack: Vec(text),
})

const ProjectPayload = Record({
  role: text,
  description: text,
  techStack: Vec(text),
})

const Portfolio = Record({
  portfolioId: text,
  portfolioPrincipal: Principal,
  education: Education,
  experiences: Vec(Experience),
  projects: Vec(Project),
  createdAt: nat64,
  updatedAt: Opt(nat64),
})

const PortfolioPayload = Record({
  title: text,
  body: text,
  attachmentURL: text,
})

type Education = typeof Education;
type Experience = typeof Experience;
type ExperiencePayload = typeof ExperiencePayload;
type Project = typeof Project;
type ProjectPayload = typeof ProjectPayload;
type Portfolio = typeof Portfolio;
type PortfolioPayload = typeof PortfolioPayload;

const portfolioStorage = StableBTreeMap(text, Portfolio, 0);


// Helper function that trims the input string and then checks the length
// The string is empty if true is returned, otherwise, string is a valid value
function isInvalidString(str: string): boolean {
  return str.trim().length == 0
}

// Helper function to ensure the input id meets the format used for ids generated by uuid
function isValidUuid(id: string): boolean {
  const regexExp = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
  return regexExp.test(id);
}



/**
 * Helper function to validate the PortfolioPayload
 * Ensures the following conditions are met:
 * 1. The title is not empty
 * 2. The attachmentURL is valid URL
 * 3. The body is not empty
 */
function validatePortfolioPayload(payload:  PortfolioPayload): Vec<string>{
  const errors: Vec<string> = [];
  // Checks if URL starts with HTTP and HTTPS
  let urlRegex= /^https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*)$/;
  if (isInvalidString(payload.title)){
      errors.push(`title='${payload.title}' cannot be empty.`)
  }
  if (!urlRegex.test(payload.attachmentURL)){
      errors.push(`attachmentURL='${payload.attachmentURL}' is not a valid URL.`)
  }
  if (isInvalidString(payload.body)){
      errors.push(`body='${payload.body}' cannot be empty.`)
  }
  return errors;
}
/**
 * Helper function to validate the ExperiencePayload
 * Ensures the following conditions are met:
 * 1. The position is not empty
 * 2. The description is not empty
 * 3. The startTime is not zero
 * 4. The endTime is not zero
 */
function validateExperiencePayload(payload:  ExperiencePayload): Vec<string>{
  const errors: Vec<string> = [];
  if (isInvalidString(payload.position)){
      errors.push(`position='${payload.position}' cannot be empty.`)
  }
  if (isInvalidString(payload.description)){
      errors.push(`description='${payload.description}' cannot be empty.`)
  }
  const zero = BigInt(0)
  if (payload.startTime == zero){
    errors.push(`Invalid start time.`)
  }
  if (payload.endTime == zero){
    errors.push(`Invalid end time.`)
  }
  return errors;
}
/**
 * Helper function to validate the ProjectPayload
 * Ensures the following conditions are met:
 * 1. The role is not empty
 * 2. The description is not empty
 * 3. The tech stack is not empty
 */
function validateProjectPayload(payload:  ProjectPayload): Vec<string>{
  const errors: Vec<string> = [];
  if (isInvalidString(payload.description)){
      errors.push(`description='${payload.description}' cannot be empty.`)
  }
  if (isInvalidString(payload.role)){
      errors.push(`role='${payload.role}' cannot be empty.`)
  }
  if (payload.techStack.length == 0){
    errors.push(`Tech stack cannot be empty.`)
  }
  return errors;
}

function isCallerPortfolioPrincipal(portfolio: Portfolio): boolean {
  return portfolio.portfolioPrincipal.toText() === ic.caller().toText()
}

export default Canister({
  getPortfolios: query([], Result(Vec(Portfolio), text), () => {
    return Result.Ok(portfolioStorage.values());
  }),

  getPortfolio: query([text], Result(Portfolio, text), (id) => {
    if (!isValidUuid(id)){
      return Result.Err(`Id='${id}' is not in the valid uuid format.`)
    }
    if (!portfolioStorage.containsKey(id)) {
      return Result.Err(`a portfolio with id=${id} not found`)
    }
    const portfolio = portfolioStorage.get(id).Some;

    return Result.Ok(portfolio);
  }),

  addEmptyPortfolio: update([PortfolioPayload], Result(Portfolio, text), (payload) => {
    const validatePayloadErrors = validatePortfolioPayload(payload);
    if (validatePayloadErrors.length){
        return Err(`Invalid payload. Errors=[${validatePayloadErrors}]`);
    }
    const education:  Education = { degree: "", school: "", graduationYear: 0 }
    const portfolio:  Portfolio = {
      portfolioId: uuidv4(),
      portfolioPrincipal: ic.caller(),
      education: education,
      experiences: [],
      projects: [],
      createdAt: ic.time(),
      updatedAt: None,
      ...payload,
    };
    portfolioStorage.insert(portfolio.portfolioId, portfolio);
    return Result.Ok(portfolio);
  }),

  addExperience: update([text, ExperiencePayload], Result(Portfolio, text), (portfolioId, payload) => {
    if (!isValidUuid(portfolioId)){
      return Result.Err(`portfolio id='${portfolioId}' is not in the valid uuid format.`)
    }
    const portfolioOpt = portfolioStorage.get(portfolioId);
    if ("None" in portfolioOpt) {
      return Err(`the portfolio with id=${portfolioId} not found`);
    }
    const portfolio: Portfolio = portfolioOpt.Some;
    if (!isCallerPortfolioPrincipal(portfolio)){
      return Err("Caller is not the principal of the portfolio.")
    }
    const validatePayloadErrors = validateExperiencePayload(payload);
    if (validatePayloadErrors.length){
        return Err(`Invalid payload. Errors=[${validatePayloadErrors}]`);
    }

    const experience:  Experience = {experienceId: uuidv4(), ...payload}

    portfolio.experiences.push(experience);
    portfolioStorage.insert(portfolio.portfolioId, portfolio);
    return Result.Ok(portfolio);
  }),

  addProject: update([text, ProjectPayload], Result(Portfolio, text), (portfolioId, payload) => {
    if (!isValidUuid(portfolioId)){
      return Result.Err(`portfolio id='${portfolioId}' is not in the valid uuid format.`)
    }

    const portfolioOpt = portfolioStorage.get(portfolioId);
    if ("None" in portfolioOpt) {
      return Err(`the portfolio with id=${portfolioId} not found`);
    }
    const portfolio : Portfolio = portfolioOpt.Some;
    if (!isCallerPortfolioPrincipal(portfolio)){
      return Err("Caller is not the principal of the portfolio.")
    }
    const validatePayloadErrors = validateProjectPayload(payload);
    if (validatePayloadErrors.length){
        return Err(`Invalid payload. Errors=[${validatePayloadErrors}]`);
    }

    const project:  Project = {projectId: uuidv4(), ...payload}

    portfolio.projects.push(project);
    portfolioStorage.insert(portfolio.portfolioId, portfolio);
    return Result.Ok(portfolio);
  }),

  updatePortfolio: update([text, PortfolioPayload], Result(Portfolio, text), (id, payload) => {
    if (!isValidUuid(id)){
      return Result.Err(`portfolio id='${id}' is not in the valid uuid format.`)
    }
    const portfolioOpt = portfolioStorage.get(id);
    if ("None" in portfolioOpt) {
      return Err(`the portfolio with id=${id} not found`);
    }
    const portfolio: Portfolio = portfolioOpt.Some;
    if (!isCallerPortfolioPrincipal(portfolio)){
      return Err("Caller is not the principal of the portfolio.")
    }
    const validatePayloadErrors = validatePortfolioPayload(payload);
    if (validatePayloadErrors.length){
        return Err(`Invalid payload. Errors=[${validatePayloadErrors}]`);
    }
    const updatedPortfolio:  Portfolio = { ...portfolio, ...payload, updatedAt: Some(ic.time()) };
    portfolioStorage.insert(portfolio.portfolioId, updatedPortfolio);

    return Result.Ok(updatedPortfolio);
  }),

  // updateExperience: update([text, text, ExperiencePayload], Result(Portfolio, text), (portfolioId, experienceId, payload) => {
  //   if (!portfolioStorage.containsKey(portfolioId)) {
  //     return Result.Err(`couldn't update a portfolio with id=${portfolioId}. portfolio not found`)
  //   }
  //   const portfolio:  Portfolio = portfolioStorage.get(portfolioId).Some;

  //   if (!portfolio.experiences.find(item => item.experienceId === experienceId)) {
  //     return Result.Err(`couldn't update a portfolio with id=${portfolioId}. experience with id=${experienceId} not found`)
  //   }

  //   const experience = portfolio.experiences.filter(item => item.experienceId !== "2");
  //   const updatedExperiences = { ...experience, ...payload }
  //   const updatedPortfolio = { ...portfolio, experiences: updatedExperiences, updatedAt: Some(ic.time()) };
  //   portfolioStorage.insert(portfolio.portfolioId, updatedPortfolio);

  //   return Result.Ok(updatedPortfolio);
  // }),

  // updateProject: update([text, text, ProjectPayload], Result(Portfolio, text), (portfolioId, projectId, payload) => {
  //   if (!portfolioStorage.containsKey(portfolioId)) {
  //     return Result.Err(`couldn't update a portfolio with id=${portfolioId}. portfolio not found`)
  //   }
  //   const portfolio:  Portfolio = portfolioStorage.get(portfolioId).Some;

  //   if (!portfolio.projects.find(item => item.projectId === projectId)) {
  //     return Result.Err(`couldn't update a portfolio with id=${portfolioId}. project with id=${projectId} not found`)
  //   }

  //   const project:  Vec(Project) = portfolio.projects.find(item => item.projectId === projectId);
  //   const updatedProjects = { ...project, ...payload }
  //   const updatedPortfolio = { ...portfolio, projects: updatedProjects, updatedAt: Some(ic.time()) };
  //   portfolioStorage.insert(portfolio.portfolioId, updatedPortfolio);

  //   return Result.Ok(updatedPortfolio);
  // }),

  deletePortfolio: update([text], Result(Portfolio, text), (id) => {
    if (!isValidUuid(id)){
      return Result.Err(`portfolio id='${id}' is not in the valid uuid format.`)
    }
    const portfolioOpt = portfolioStorage.get(id);
    if ("None" in portfolioOpt) {
      return Err(`the portfolio with id=${id} not found`);
    }
    const portfolio: Portfolio = portfolioOpt.Some;
    if (!isCallerPortfolioPrincipal(portfolio)){
      return Err("Caller is not the principal of the portfolio.")
    }
    const deletedPortfolio = portfolioStorage.remove(id);
    return Result.Ok(deletedPortfolio);
  }),

  deleteExperience: update([text, text], Result(Portfolio, text), (portfolioId, experienceId) => {
    if (!isValidUuid(portfolioId)){
      return Result.Err(`portfolio id='${portfolioId}' is not in the valid uuid format.`)
    }
    if (!isValidUuid(experienceId)){
      return Result.Err(`experience id='${experienceId}' is not in the valid uuid format.`)
    }
    const portfolioOpt = portfolioStorage.get(portfolioId);
    if ("None" in portfolioOpt) {
      return Err(`the portfolio with id=${portfolioId} not found`);
    }
    const portfolio: Portfolio = portfolioOpt.Some;
    if (!isCallerPortfolioPrincipal(portfolio)){
      return Err("Caller is not the principal of the portfolio.")
    }
    if (!portfolio.experiences.find(item => item.experienceId === experienceId)) {
      return Result.Err(`couldn't delete an experience at portfolio with id=${portfolioId}. experience not found.`)
    }

    const updatedExperiences = portfolio.experiences.filter((item:  Experience) => item.experienceId !== experienceId)
    const updatedPortfolio:  Portfolio = { ...portfolio, experiences: updatedExperiences, updatedAt: Some(ic.time()) };
    portfolioStorage.insert(portfolio.portfolioId, updatedPortfolio);

    return Result.Ok(updatedPortfolio);
  }),

  deleteProject: update([text, text], Result(Portfolio, text), (portfolioId, projectId) => {
    if (!isValidUuid(portfolioId)){
      return Result.Err(`portfolio id='${portfolioId}' is not in the valid uuid format.`)
    }
    if (!isValidUuid(projectId)){
      return Result.Err(`project id='${projectId}' is not in the valid uuid format.`)
    }
    const portfolioOpt = portfolioStorage.get(portfolioId);
    if ("None" in portfolioOpt) {
      return Err(`the portfolio with id=${portfolioId} not found`);
    }
    const portfolio: Portfolio = portfolioOpt.Some;
    if (!isCallerPortfolioPrincipal(portfolio)){
      return Err("Caller is not the principal of the portfolio.")
    }
    if (!portfolio.projects.find(item => item.projectId === projectId)) {
      return Result.Err(`couldn't delete an project at portfolio with id=${portfolioId}. project not found.`)
    }

    const Projects = portfolio.projects.filter((item:  Project) => item.projectId !== projectId)
    const updatedPortfolio:  Portfolio = { ...portfolio, projects: Projects, updatedAt: Some(ic.time()) };
    portfolioStorage.insert(portfolio.portfolioId, updatedPortfolio);

    return Result.Ok(updatedPortfolio);
  }),

})

// a workaround to make uuid package work with Azle
globalThis.crypto = {
  // @ts-ignore
  getRandomValues: () => {
    let array = new Uint8Array(32);

    for (let i = 0; i < array.length; i++) {
      array[i] = Math.floor(Math.random() * 256);
    }

    return array;
  }
};
